//! TypeScript file writer
//!
//! Writes generated Blockly definitions to TypeScript files

use super::{ArgType, BlockArg, BlockDefinition, BlocklyOutput, ConnectionType};
use std::path::PathBuf;

/// Write block definitions to TypeScript file
pub fn write_blockly_blocks(theory_name: &str, output: &BlocklyOutput) -> std::io::Result<()> {
    let filename = format!("{}-blocks.ts", theory_name.to_lowercase());
    let path = get_output_path(&filename)?;

    let content = generate_blocks_typescript(output);

    std::fs::write(&path, content)?;
    eprintln!("Generated Blockly blocks: {}", path.display());

    Ok(())
}

/// Write category metadata to TypeScript file
pub fn write_blockly_categories(theory_name: &str, output: &BlocklyOutput) -> std::io::Result<()> {
    let filename = format!("{}-categories.ts", theory_name.to_lowercase());
    let path = get_output_path(&filename)?;

    let content = generate_categories_typescript(output);

    std::fs::write(&path, content)?;
    eprintln!("Generated Blockly categories: {}", path.display());

    Ok(())
}

/// Get output path for generated files
fn get_output_path(filename: &str) -> std::io::Result<PathBuf> {
    // Get workspace root (parent of macros/)
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap_or_else(|_| ".".to_string());

    let mut path = PathBuf::from(manifest_dir);
    path.pop(); // Go up from macros/ to workspace root
    path.push("theories");
    path.push("src");
    path.push("generated");

    // Create directory if it doesn't exist
    std::fs::create_dir_all(&path)?;

    path.push(filename);
    Ok(path)
}

/// Generate TypeScript for block definitions
fn generate_blocks_typescript(output: &BlocklyOutput) -> String {
    let mut ts = String::new();

    // Header
    ts.push_str(&format!("// Generated Blockly blocks for {} theory\n", output.theory_name));
    ts.push_str("// DO NOT EDIT - generated by MeTTaIL theory! macro\n");
    ts.push_str("// Changes will be overwritten on next build\n\n");

    ts.push_str("import * as Blockly from \"blockly/core\";\n\n");

    // Block definitions array
    ts.push_str("const definitions = [\n");

    for (i, block) in output.blocks.iter().enumerate() {
        if i > 0 {
            ts.push_str(",\n\n");
        }
        ts.push_str(&generate_block_object(block));
    }

    ts.push_str("\n];\n\n");

    // Export
    ts.push_str(
        "export default Blockly.common.createBlockDefinitionsFromJsonArray(definitions);\n",
    );

    ts
}

/// Generate TypeScript object for a single block
fn generate_block_object(block: &BlockDefinition) -> String {
    let mut obj = String::new();

    obj.push_str(&format!("\t// {}\n", block.tooltip));
    obj.push_str("\t{\n");
    obj.push_str(&format!("\t\ttype: \"{}\",\n", block.block_type));
    obj.push_str(&format!("\t\ttooltip: \"{}\",\n", escape_string(&block.tooltip)));
    obj.push_str(&format!("\t\tmessage0: \"{}\",\n", escape_string(&block.message)));

    // Args
    if !block.args.is_empty() {
        obj.push_str("\t\targs0: [\n");
        for arg in &block.args {
            obj.push_str(&generate_arg_object(arg));
        }
        obj.push_str("\t\t],\n");
    }

    // Inline inputs
    if block.inputs_inline {
        obj.push_str("\t\tinputsInline: true,\n");
    }

    // Connection type
    match &block.connection_type {
        ConnectionType::Value { output } => {
            obj.push_str(&format!("\t\toutput: \"{}\",\n", output));
        },
        ConnectionType::Statement { previous, next } => {
            obj.push_str(&format!("\t\tpreviousStatement: \"{}\",\n", previous));
            obj.push_str(&format!("\t\tnextStatement: \"{}\",\n", next));
        },
    }

    // Color
    obj.push_str(&format!("\t\tcolour: \"{}\",\n", block.colour));

    obj.push_str("\t}");

    obj
}

/// Generate TypeScript object for a block argument
fn generate_arg_object(arg: &BlockArg) -> String {
    let mut obj = String::new();

    obj.push_str("\t\t\t{\n");

    // Type
    let type_str = match arg.arg_type {
        ArgType::InputValue => "input_value",
        ArgType::InputStatement => "input_statement",
        ArgType::FieldInput => "field_input",
    };
    obj.push_str(&format!("\t\t\t\ttype: \"{}\",\n", type_str));

    // Name
    obj.push_str(&format!("\t\t\t\tname: \"{}\",\n", arg.name));

    // Check
    if let Some(check) = &arg.check {
        obj.push_str(&format!("\t\t\t\tcheck: \"{}\",\n", check));
    }

    // Text (for field_input)
    if let Some(text) = &arg.text {
        obj.push_str(&format!("\t\t\t\ttext: \"{}\",\n", text));
    }

    obj.push_str("\t\t\t},\n");

    obj
}

/// Generate TypeScript for category metadata
fn generate_categories_typescript(output: &BlocklyOutput) -> String {
    let mut ts = String::new();

    // Header
    ts.push_str(&format!("// Generated category metadata for {} theory\n", output.theory_name));
    ts.push_str("// DO NOT EDIT - generated by MeTTaIL theory! macro\n\n");

    // Category info object
    ts.push_str("export const categoryInfo = {\n");

    let mut cats: Vec<_> = output.categories.values().collect();
    cats.sort_by_key(|c| &c.name);

    for (i, cat) in cats.iter().enumerate() {
        if i > 0 {
            ts.push_str(",\n");
        }

        ts.push_str(&format!("\t{}: {{\n", cat.name));
        ts.push_str("\t\tconstructors: [\n");

        for (j, ctor) in cat.constructors.iter().enumerate() {
            if j > 0 {
                ts.push_str(",\n");
            }
            ts.push_str(&format!("\t\t\t\"{}\"", ctor));
        }

        ts.push_str("\n\t\t],\n");
        ts.push_str(&format!("\t\tcolour: \"{}\",\n", cat.colour));
        ts.push_str("\t}");
    }

    ts.push_str("\n};\n\n");

    // Theory name
    ts.push_str(&format!("export const theoryName = \"{}\";\n", output.theory_name));

    ts
}

/// Escape string for TypeScript
fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_escape_string() {
        assert_eq!(escape_string("hello"), "hello");
        assert_eq!(escape_string("hello \"world\""), "hello \\\"world\\\"");
        assert_eq!(escape_string("line1\nline2"), "line1\\nline2");
    }
}
