// LALRPOP grammar generation for MeTTaIL theories
//
// This module generates `.lalrpop` grammar files from theory definitions.
// The generated grammars parse text into the AST types generated by codegen.rs

#![allow(clippy::cmp_owned, clippy::useless_format)]

use crate::ast::{GrammarItem, GrammarRule, TheoryDef};
use crate::codegen::{is_integer_rule, is_var_rule};
use crate::utils::{has_native_type, native_type_to_string};

/// Generates Var label for a category (first letter + "Var")
fn generate_var_label(category: &syn::Ident) -> String {
    let cat_str = category.to_string();
    let first_letter = cat_str
        .chars()
        .next()
        .unwrap_or('V')
        .to_uppercase()
        .collect::<String>();
    format!("{}Var", first_letter)
}


/// Generate token parser for native type if needed
fn generate_native_type_tokens(theory: &TheoryDef) -> String {
    let mut tokens = String::new();
    
    // Check all exports for native types and generate appropriate token parsers
    for export in &theory.exports {
        if let Some(ref native_type) = export.native_type {
            let type_str = native_type_to_string(native_type);
            
            // Generate token parser based on native type
            if type_str == "i32" || type_str == "i64" {
                tokens.push_str(&format!("Integer: {} = {{\n", type_str));
                // Only match positive integers at token level
                // Negative integers will be handled in the grammar via unary minus
                tokens.push_str("    r\"[0-9]+\" => <>.parse().unwrap_or(0),\n");
                tokens.push_str("};\n\n");
            } else if type_str == "f32" || type_str == "f64" {
                tokens.push_str(&format!("Float: {} = {{\n", type_str));
                tokens.push_str("    r\"[0-9]+\\.[0-9]+\" => <>.parse().unwrap_or(0.0),\n");
                tokens.push_str("};\n\n");
            } else if type_str == "bool" {
                tokens.push_str("Boolean: bool = {\n");
                tokens.push_str("    \"true\" => true,\n");
                tokens.push_str("    \"false\" => false,\n");
                tokens.push_str("};\n\n");
            }
            // Add more native types as needed
        }
    }
    
    tokens
}

/// Generate a LALRPOP grammar file content for a theory
///
/// This produces the text content of a `.lalrpop` file that can parse
/// the theory's syntax into its AST types.
pub fn generate_lalrpop_grammar(theory: &TheoryDef) -> String {
    let theory_name = &theory.name;

    let mut grammar = String::new();

    // Add header
    grammar.push_str(&format!("// Generated LALRPOP grammar for theory: {}\n", theory_name));
    grammar.push_str("// This file is auto-generated - do not edit manually\n\n");

    // Add use statements for runtime helpers. Only include what's needed
    let has_binders = theory.terms.iter().any(|r| !r.bindings.is_empty());
    
    // Check if any category needs Var (i.e., has non-native exports OR has Var rules)
    let needs_var = theory.exports.iter().any(|e| e.native_type.is_none())
        || theory.terms.iter().any(|r| is_var_rule(r));
    
    if has_binders {
        if needs_var {
            grammar.push_str("use mettail_runtime::{Var, Binder, Scope};\n");
        } else {
            grammar.push_str("use mettail_runtime::{Binder, Scope};\n");
        }
    } else if needs_var {
        grammar.push_str("use mettail_runtime::{Var};\n");
    }

    // Import the AST types from the crate where the theory is defined
    // When used in test modules, this will be super::{...}
    // When used in library modules, LALRPOP will handle the paths correctly
    let type_names: Vec<String> = theory.exports.iter().map(|e| e.name.to_string()).collect();

    if !type_names.is_empty() {
        grammar.push_str(&format!("use super::{{{}}};\n", type_names.join(", ")));
    }

    grammar.push('\n');

    // Add grammar directive
    grammar.push_str("grammar;\n\n");

    // Add identifier token definition (needed for binders and variables)
    grammar.push_str("Ident: String = {\n");
    grammar.push_str("    r\"[a-zA-Z_][a-zA-Z0-9_]*\" => <>.to_string(),\n");
    grammar.push_str("};\n\n");

    // Generate native type token parsers if needed
    grammar.push_str(&generate_native_type_tokens(theory));

    // Generate productions for each exported category
    for export in &theory.exports {
        let cat_name = &export.name;

        // Find all rules for this category
        let rules: Vec<&GrammarRule> = theory
            .terms
            .iter()
            .filter(|r| r.category == *cat_name)
            .collect();

        // Always generate production (even if no rules, we might need Var)
        grammar.push_str(&generate_category_production(cat_name, &rules, theory));
        grammar.push('\n');
    }

    grammar
}

/// Generate a LALRPOP production for a category
///
/// This handles precedence by creating tiered rules for infix operators
fn generate_category_production(category: &syn::Ident, rules: &[&GrammarRule], theory: &TheoryDef) -> String {
    let _cat_str = category.to_string();

    // Checks if there's already a Var rule
    let has_var_rule = rules.iter().any(|r| is_var_rule(r));

    // Classify rules by type
    let (infix_rules, other_rules): (Vec<&GrammarRule>, Vec<&GrammarRule>) =
        rules.iter().copied().partition(|r| is_infix_rule(r));

    // If we have infix operators, generate tiered rules for precedence
    if !infix_rules.is_empty() {
        generate_tiered_production(category, &infix_rules, &other_rules, has_var_rule, theory)
    } else {
        // No infix operators - generate simple production
        generate_simple_production(category, &other_rules, has_var_rule, theory)
    }
}

/// Check if a rule is an infix operator (e.g., Proc ::= Proc "|" Proc)
fn is_infix_rule(rule: &GrammarRule) -> bool {
    // An infix rule has the pattern: NonTerm (Terminal | NonTerm)+ NonTerm
    // where the first and last non-terminals are the same as the rule's category
    if rule.items.len() < 3 {
        return false;
    }

    // Check if first item is the same category
    let first_match = matches!(&rule.items[0],
        GrammarItem::NonTerminal(nt) if nt == &rule.category);

    // Check if last item is the same category
    let last_match = matches!(rule.items.last(),
        Some(GrammarItem::NonTerminal(nt)) if nt == &rule.category);

    // Check if there's a terminal in the middle (the operator)
    let has_terminal = rule.items[1..rule.items.len() - 1]
        .iter()
        .any(|item| matches!(item, GrammarItem::Terminal(_)));

    first_match && last_match && has_terminal
}

/// Generate tiered production for handling precedence
fn generate_tiered_production(
    category: &syn::Ident,
    infix_rules: &[&GrammarRule],
    other_rules: &[&GrammarRule],
    has_var_rule: bool,
    theory: &TheoryDef,
) -> String {
    let cat_str = category.to_string();
    let mut production = String::new();

    // Top-level rule just delegates to the infix tier
    production.push_str(&format!("pub {}: {} = {{\n", cat_str, cat_str));
    production.push_str(&format!("    <{}Infix>\n", cat_str));
    production.push_str("};\n\n");

    // Infix tier - handles left-associative operators
    production.push_str(&format!("{}Infix: {} = {{\n", cat_str, cat_str));

    // Generate left-recursive rules for infix operators
    for rule in infix_rules.iter() {
        production.push_str("    ");
        production.push_str(&generate_infix_alternative(rule, &cat_str));
        production.push_str(",\n");
    }

    // Base case - delegate to atom tier
    production.push_str(&format!("    <{}Atom>\n", cat_str));
    production.push_str("};\n\n");

    // Atom tier - handles non-infix constructs and parentheses
    production.push_str(&format!("{}Atom: {} = {{\n", cat_str, cat_str));

    // Add parenthesized expressions - reference the top-level rule
    production.push_str(&format!("    \"(\" <{}> \")\",\n", cat_str));

    // Add unary minus support for native integer types (before other rules for precedence)
    if let Some(native_type) = has_native_type(category, theory) {
        let type_str = native_type_to_string(native_type);
        if type_str == "i32" || type_str == "i64" {
            // Find the Integer rule (for integer literals)
            if let Some(integer_rule) = other_rules.iter().find(|r| is_integer_rule(r)) {
                let integer_label = integer_rule.label.to_string();
                production.push_str(&format!(
                    "    \"-\" <i:Integer> => {}::{}(-i),\n",
                    cat_str, integer_label
                ));
            }
        }
    }

    // Add non-infix rules
    for (i, rule) in other_rules.iter().enumerate() {
        production.push_str("    ");
        production.push_str(&generate_rule_alternative_with_theory(rule, Some(theory)));

        if i < other_rules.len() - 1 {
            production.push_str(",\n");
        } else {
            production.push('\n');
        }
    }

    // Automatically adds Var alternative if it doesn't exist (lowest precedence)
    // But check for native types first - if category has native type, use native literal parser
    if !has_var_rule {
        let var_label = generate_var_label(category);
        // Check if this category has a native type
        if let Some(native_type) = has_native_type(category, theory) {
            let type_str = native_type_to_string(native_type);
            if type_str == "i32" || type_str == "i64" {
                // Use Integer token for native integer types
                // Also add unary minus support for negative numbers
                production.push_str(&format!(
                    "    \"-\" <i:Integer> => {}::{}(-i),\n",
                    cat_str, var_label
                ));
                production.push_str(&format!(
                    "    <i:Integer> => {}::{}(i)\n",
                    cat_str, var_label
                ));
            } else {
                // Other native types - fall back to Var for now
                production.push_str(&format!(
                    "    <v:Ident> => {}::{}(mettail_runtime::OrdVar(Var::Free(mettail_runtime::get_or_create_var(v))))\n",
                    cat_str, var_label
                ));
            }
        } else {
            // No native type - use regular Var
            production.push_str(&format!(
                "    <v:Ident> => {}::{}(mettail_runtime::OrdVar(Var::Free(mettail_runtime::get_or_create_var(v))))\n",
                cat_str, var_label
            ));
        }
    }

    production.push_str("};\n");
    production
}

/// Generate alternative for infix operator (left-associative)
fn generate_infix_alternative(rule: &GrammarRule, cat_str: &str) -> String {
    let label = &rule.label;
    let category = &rule.category;

    // Pattern: <left:Cat> "op" <right:CatAtom>
    // This ensures left-associativity
    let mut pattern = format!("<left:{}Infix>", cat_str);

    // Process items to find operator and right operand
    for (i, item) in rule.items.iter().enumerate() {
        if i == 0 {
            continue; // Skip first (it's the left operand)
        }

        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) if nt == category && i == rule.items.len() - 1 => {
                // Last item - use Atom tier to avoid ambiguity
                pattern.push_str(&format!(" <right:{}Atom>", cat_str));
            },
            GrammarItem::NonTerminal(nt) if nt == category => {
                // Middle recursive reference - shouldn't happen in binary infix
                pattern.push_str(&format!(" <mid{}>", i));
            },
            GrammarItem::NonTerminal(_) => {
                pattern.push_str(&format!(" <f{}>", i));
            },
            GrammarItem::Collection { .. } => {
                // Collections in infix operators not yet supported (Phase 4)
                panic!("Collection types in infix operators not yet implemented (Phase 4)");
            },
            GrammarItem::Binder { .. } => {
                // Binders in infix operators - unusual but handle it
                pattern.push_str(&format!(" <x_{}>", i));
            },
        }
    }

    // Generate action
    let action = format!(" => {}::{}(Box::new(left), Box::new(right))", category, label);

    format!("{}{}", pattern, action)
}

/// Generate simple production (no infix operators)
fn generate_simple_production(
    category: &syn::Ident,
    rules: &[&GrammarRule],
    has_var_rule: bool,
    theory: &TheoryDef,
) -> String {
    let mut production = String::new();

    // Production header: pub CategoryName: CategoryName = {
    production.push_str(&format!("pub {}: {} = {{\n", category, category));

    // Generate alternative for each rule
    for (i, rule) in rules.iter().enumerate() {
        production.push_str("    ");
        // Pass theory context for native type detection
        production.push_str(&generate_rule_alternative_with_theory(rule, Some(theory)));

        // Adds comma unless it's the last rule and we won't add Var
        if i < rules.len() - 1 || !has_var_rule {
            production.push_str(",\n");
        } else {
            production.push('\n');
        }
    }

    // Automatically adds Var alternative if it doesn't exist (lowest precedence)
    // But check for native types first - if category has native type, use native literal parser
    if !has_var_rule {
        let var_label = generate_var_label(category);
        // Check if this category has a native type
        if let Some(native_type) = has_native_type(category, theory) {
            let type_str = native_type_to_string(native_type);
            if type_str == "i32" || type_str == "i64" {
                // Use Integer token for native integer types
                // Also add unary minus support for negative numbers
                production.push_str(&format!(
                    "    \"-\" <i:Integer> => {}::{}(-i),\n",
                    category, var_label
                ));
                production.push_str(&format!(
                    "    <i:Integer> => {}::{}(i)\n",
                    category, var_label
                ));
            } else {
                // Other native types - fall back to Var for now
                production.push_str(&format!(
                    "    <v:Ident> => {}::{}(mettail_runtime::OrdVar(Var::Free(mettail_runtime::get_or_create_var(v))))\n",
                    category, var_label
                ));
            }
        } else {
            // No native type - use regular Var
            production.push_str(&format!(
                "    <v:Ident> => {}::{}(mettail_runtime::OrdVar(Var::Free(mettail_runtime::get_or_create_var(v))))\n",
                category, var_label
            ));
        }
    }

    production.push_str("};\n");
    production
}

/// Generate a LALRPOP alternative for a single grammar rule (with theory context for native types)
fn generate_rule_alternative_with_theory(rule: &GrammarRule, _theory: Option<&TheoryDef>) -> String {
    let label = &rule.label;
    let mut alt = String::new();

    // Generate pattern for matching the syntax
    // Example: PZero . Proc ::= "0" ;
    //   becomes: "0" => Proc::PZero

    // Handle different cases based on rule structure
    if rule.items.len() == 1 {
        // Single item (terminal or non-terminal)
        match &rule.items[0] {
            GrammarItem::Terminal(term) => {
                // Terminal: just match the literal
                alt.push_str(&format!("\"{}\" => {}::{}", term, rule.category, label));
            },
            GrammarItem::NonTerminal(nt) if nt == "Integer" => {
                // Integer keyword: parse Integer token directly for native integer literals
                alt.push_str(&format!("<i:Integer> => {}::{}(i)", rule.category, label));
            },
            GrammarItem::NonTerminal(nt) if nt == "Var" => {
                // Variable: parse identifier as variable node
                // Use get_or_create_var to ensure same name = same ID within a parse
                alt.push_str(&format!("<v:Ident> => {}::{}(mettail_runtime::OrdVar(Var::Free(mettail_runtime::get_or_create_var(v))))",
                    rule.category, label));
            },
            GrammarItem::NonTerminal(nt) => {
                // Non-terminal: recursively parse
                alt.push_str(&format!(
                    "<val:{}> => {}::{}(Box::new(val))",
                    nt, rule.category, label
                ));
            },
            GrammarItem::Collection {
                coll_type,
                element_type,
                separator,
                delimiters,
            } => {
                // Single-item collection - generate the collection alternative
                return generate_collection_alternative(
                    rule,
                    coll_type,
                    element_type,
                    separator,
                    delimiters.as_ref(),
                );
            },
            GrammarItem::Binder { .. } => {
                // Binder alone shouldn't happen
                alt.push_str(&format!("// TODO: handle binder => {}::{}", rule.category, label));
            },
        }
    } else {
        // Multiple items: need to handle sequence
        alt.push_str(&generate_sequence_alternative(rule));
    }

    alt
}

/// Generate alternative for a rule with multiple items
fn generate_sequence_alternative(rule: &GrammarRule) -> String {
    let label = &rule.label;
    let category = &rule.category;

    // Check if this rule has binders
    if !rule.bindings.is_empty() {
        return generate_binder_alternative(rule);
    }

    let mut pattern = String::new();
    let mut args = Vec::new();
    let mut field_idx = 0;

    for item in &rule.items {
        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) => {
                let var_name = format!("f{}", field_idx);
                pattern.push_str(&format!(" <{}:{}>", var_name, nt));

                if nt.to_string() == "Var" {
                    // Wrap Var in OrdVar
                    args.push(format!("mettail_runtime::OrdVar({})", var_name));
                } else {
                    args.push(format!("Box::new({})", var_name));
                }
                field_idx += 1;
            },
            GrammarItem::Collection {
                coll_type,
                element_type,
                separator,
                delimiters,
            } => {
                // Generate LALRPOP rule for separated list
                return generate_collection_alternative(
                    rule,
                    coll_type,
                    element_type,
                    separator,
                    delimiters.as_ref(),
                );
            },
            GrammarItem::Binder { category: _binder_cat } => {
                // Binder: parse as identifier
                let var_name = format!("b{}", field_idx);
                pattern.push_str(&format!(" <{}:Ident>", var_name));
                // Binders are captured in Scope, handled separately
                field_idx += 1;
            },
        }
    }

    // Construct the AST node
    let args_str = args.join(", ");
    format!("{} => {}::{}({})", pattern.trim(), category, label, args_str)
}

/// Generate alternative for a rule with binders (creates Scope)
fn generate_binder_alternative(rule: &GrammarRule) -> String {
    let label = &rule.label;
    let category = &rule.category;

    let (binder_idx, body_indices) = &rule.bindings[0];
    let body_idx = body_indices[0];

    // Generate pattern and track which items go where
    let mut pattern = String::new();
    let mut regular_fields = Vec::new();
    let mut binder_var = String::new();
    let mut body_var = String::new();
    let mut field_idx = 0;

    for (i, item) in rule.items.iter().enumerate() {
        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) => {
                if i == body_idx {
                    // This is the body
                    body_var = format!("body_{}", field_idx);
                    pattern.push_str(&format!(" <{}:{}>", body_var, nt));
                } else {
                    // Regular field (not binder, not body)
                    let var_name = format!("f{}", field_idx);
                    pattern.push_str(&format!(" <{}:{}>", var_name, nt));

                    if nt.to_string() == "Var" {
                        regular_fields.push(var_name);
                    } else {
                        regular_fields.push(format!("Box::new({})", var_name));
                    }
                }
                field_idx += 1;
            },
            GrammarItem::Collection { .. } => {
                // Collections in binder rules not yet supported (Phase 4)
                panic!("Collection types in binder rules not yet implemented (Phase 4)");
            },
            GrammarItem::Binder { .. } => {
                if i == *binder_idx {
                    // This is the binder - parse as identifier
                    binder_var = format!("x_{}", field_idx);
                    pattern.push_str(&format!(" <{}:Ident>", binder_var));
                }
                field_idx += 1;
            },
        }
    }

    // Generate the action code that creates Scope
    // We need to extract the free variable from the body that matches the binder name
    // and use it as the binder, so moniker can properly bind it
    let mut action = format!(" => {{\n");
    action.push_str("        use mettail_runtime::BoundTerm;\n");
    action.push_str(&format!("        let free_vars = {}.free_vars();\n", body_var));
    action.push_str(&format!("        let binder = if let Some(fv) = free_vars.iter().find(|fv| fv.pretty_name.as_deref() == Some(&{})) {{\n", binder_var));
    action.push_str("            Binder((*fv).clone())\n");
    action.push_str("        } else {\n");
    action.push_str(&format!(
        "            Binder(mettail_runtime::get_or_create_var({}))\n",
        binder_var
    ));
    action.push_str("        };\n");
    action.push_str(&format!("        let scope = Scope::new(binder, Box::new({}));\n", body_var));

    // Build constructor call
    let mut all_args = regular_fields;
    all_args.push("scope".to_string());

    action.push_str(&format!("        {}::{}({})\n", category, label, all_args.join(", ")));
    action.push_str("    }");

    format!("{}{}", pattern.trim(), action)
}

/// Generate alternative for a collection constructor
///
/// Generates LALRPOP rules for separated lists with optional delimiters.
/// Examples:
/// - `a | b | c` (no delimiters)
/// - `[a, b, c]` (with delimiters)
/// - `[]` (empty collection)
fn generate_collection_alternative(
    rule: &GrammarRule,
    coll_type: &crate::ast::CollectionType,
    element_type: &syn::Ident,
    separator: &str,
    delimiters: Option<&(String, String)>,
) -> String {
    let label = &rule.label;
    let category = &rule.category;

    // Escape separator for LALRPOP
    // Special handling for "|" which has meaning in LALRPOP grammar syntax
    let sep_escaped = if separator == "|" {
        r"\|".to_string()
    } else {
        separator.replace("\"", "\\\"")
    };

    // Determine if we need to use regex pattern (for special chars like |)
    let sep_pattern = if separator == "|" {
        format!("r\"{}\"", sep_escaped)
    } else {
        format!("\"{}\"", sep_escaped)
    };

    // Determine the collection type constructor
    let coll_constructor = match coll_type {
        crate::ast::CollectionType::HashBag => "mettail_runtime::HashBag",
        crate::ast::CollectionType::HashSet => "std::collections::HashSet",
        crate::ast::CollectionType::Vec => "Vec",
    };

    // Build the pattern
    // For separated lists, we use: <elems:(<Elem> "sep")*> <last:Elem?>
    // This allows optional trailing separator
    let mut pattern = String::new();

    if let Some((open, close)) = delimiters {
        // With delimiters: `{` <elems> `}`
        // LALRPOP syntax: (X Y)* creates Vec<(X,Y)>, but (<X> Y)* creates Vec<X>
        // LALRPOP automatically handles whitespace between tokens
        let open_escaped = open.replace("\"", "\\\"");
        let close_escaped = close.replace("\"", "\\\"");
        pattern.push_str(&format!("\"{}\" ", open_escaped));
        // Capture just the element, discard the separator
        pattern.push_str(&format!("<elems:(<{}> {})*> ", element_type, sep_pattern));
        pattern.push_str(&format!("<last:{}?> ", element_type));
        pattern.push_str(&format!("\"{}\"", close_escaped));
    } else {
        // Without delimiters: just the separated list
        // Use <> to only capture the element, not the separator
        // LALRPOP automatically handles whitespace between tokens
        pattern.push_str(&format!("<first:{}> ", element_type));
        pattern.push_str(&format!("<rest:({} <{}>)*>", sep_pattern, element_type));
    }

    // Build the action
    let mut action = String::from(" => {\n");
    action.push_str(&format!("        let mut coll = {}::new();\n", coll_constructor));

    if delimiters.is_some() {
        // With delimiters: use elems and last pattern
        action.push_str("        for e in elems {\n");
        match coll_type {
            crate::ast::CollectionType::HashBag => {
                action.push_str("            coll.insert(e);\n");
            },
            crate::ast::CollectionType::HashSet => {
                action.push_str("            coll.insert(e);\n");
            },
            crate::ast::CollectionType::Vec => {
                action.push_str("            coll.push(e);\n");
            },
        }
        action.push_str("        }\n");
        action.push_str("        if let Some(e) = last {\n");
        match coll_type {
            crate::ast::CollectionType::HashBag => {
                action.push_str("            coll.insert(e);\n");
            },
            crate::ast::CollectionType::HashSet => {
                action.push_str("            coll.insert(e);\n");
            },
            crate::ast::CollectionType::Vec => {
                action.push_str("            coll.push(e);\n");
            },
        }
        action.push_str("        }\n");
    } else {
        // Without delimiters: use first and rest pattern
        match coll_type {
            crate::ast::CollectionType::HashBag => {
                action.push_str("        coll.insert(first);\n");
                action.push_str("        for e in rest {\n");
                action.push_str("            coll.insert(e);\n");
                action.push_str("        }\n");
            },
            crate::ast::CollectionType::HashSet => {
                action.push_str("        coll.insert(first);\n");
                action.push_str("        for e in rest {\n");
                action.push_str("            coll.insert(e);\n");
                action.push_str("        }\n");
            },
            crate::ast::CollectionType::Vec => {
                action.push_str("        coll.push(first);\n");
                action.push_str("        for e in rest {\n");
                action.push_str("            coll.push(e);\n");
                action.push_str("        }\n");
            },
        }
    }

    action.push_str(&format!("        {}::{}(coll)\n", category, label));
    action.push_str("    }");

    format!("{}{}", pattern.trim(), action)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::*;
    use syn::parse_quote;

    #[test]
    fn test_automatic_var_in_parser() {
        // Tests theory without Var rules - they should be automatically generated in parser
        let theory = TheoryDef {
            name: parse_quote!(Test),
            params: vec![],
            exports: vec![Export { name: parse_quote!(Proc), native_type: None }, Export { name: parse_quote!(Name), native_type: None }],
            terms: vec![
                GrammarRule {
                    label: parse_quote!(PZero),
                    category: parse_quote!(Proc),
                    items: vec![GrammarItem::Terminal("0".to_string())],
                    bindings: vec![],
                },
                GrammarRule {
                    label: parse_quote!(NQuote),
                    category: parse_quote!(Name),
                    items: vec![
                        GrammarItem::Terminal("@".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Proc)),
                    ],
                    bindings: vec![],
                },
                // No Var rules explicitly defined
            ],
            equations: vec![],
            rewrites: vec![],
            semantics: vec![],
        };

        let grammar = generate_lalrpop_grammar(&theory);
        println!("Generated grammar:\n{}", grammar);

        // Checks that Var alternatives are automatically generated for each exported category
        // Proc -> PVar
        assert!(
            grammar.contains(
                "PVar(mettail_runtime::OrdVar(Var::Free(mettail_runtime::get_or_create_var(v))))"
            ),
            "Expected PVar parser alternative for Proc category"
        );
        // Name -> NVar
        assert!(
            grammar.contains(
                "NVar(mettail_runtime::OrdVar(Var::Free(mettail_runtime::get_or_create_var(v))))"
            ),
            "Expected NVar parser alternative for Name category"
        );

        // Verifies the grammar structure
        assert!(grammar.contains("pub Proc: Proc"));
        assert!(grammar.contains("pub Name: Name"));
        assert!(grammar.contains("<v:Ident>"));
    }

    #[test]
    fn test_automatic_var_in_parser_with_existing_var() {
        // Tests that if a Var rule already exists, we don't generate a duplicate
        let theory = TheoryDef {
            name: parse_quote!(Test),
            params: vec![],
            exports: vec![Export { name: parse_quote!(Proc), native_type: None }],
            terms: vec![
                GrammarRule {
                    label: parse_quote!(PZero),
                    category: parse_quote!(Proc),
                    items: vec![GrammarItem::Terminal("0".to_string())],
                    bindings: vec![],
                },
                GrammarRule {
                    label: parse_quote!(PVar),
                    category: parse_quote!(Proc),
                    items: vec![GrammarItem::NonTerminal(parse_quote!(Var))],
                    bindings: vec![],
                },
                // Var rule explicitly defined
            ],
            equations: vec![],
            rewrites: vec![],
            semantics: vec![],
        };

        let grammar = generate_lalrpop_grammar(&theory);
        println!("Generated grammar:\n{}", grammar);

        // Should have exactly one PVar alternative (the explicitly defined one)
        let pvar_count = grammar.matches("PVar").count();
        assert_eq!(pvar_count, 1, "Expected exactly one PVar alternative, found {}", pvar_count);
        assert!(
            grammar.contains(
                "PVar(mettail_runtime::OrdVar(Var::Free(mettail_runtime::get_or_create_var(v))))"
            ),
            "Expected PVar parser alternative"
        );
    }

    #[test]
    fn test_var_label_generation() {
        // Tests that Var labels are generated correctly for different category names
        assert_eq!(generate_var_label(&parse_quote!(Proc)), "PVar");
        assert_eq!(generate_var_label(&parse_quote!(Name)), "NVar");
        assert_eq!(generate_var_label(&parse_quote!(Term)), "TVar");
        assert_eq!(generate_var_label(&parse_quote!(Expr)), "EVar");
        assert_eq!(generate_var_label(&parse_quote!(Type)), "TVar");
    }
}
