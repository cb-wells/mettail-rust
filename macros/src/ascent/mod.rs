//! Ascent Datalog code generation
//!
//! This module orchestrates the generation of Ascent Datalog code for a theory.
//!
//! ## Structure
//!
//! - `relations` - Relation declarations (categories, equality, rewrites, projections)
//! - `categories` - Category exploration and term deconstruction rules
//! - `equations` - Equality/equation rules with congruence
//! - `rewrites/` - Base rewrite rules and pattern/RHS generation
//! - `congruence/` - Congruence rules for rewrites (collection, regular, binding)
//!
//! ## Generated Code Components
//!
//! 1. **Relations**: Declare all Ascent relations for terms, equality, and rewrites
//! 2. **Category Rules**: Explore term space via rewrites and deconstruct terms
//! 3. **Equation Rules**: Add reflexivity, congruence, and user-defined equalities
//! 4. **Rewrite Rules**: Base rewrites + congruence rules (propagate through constructors)

use crate::{
    ast::TheoryDef,
    codegen::{generate_var_label, is_var_rule},
    utils::print_rule,
};
use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};

mod categories;
mod equations;
mod relations;
mod writer;

pub mod congruence;
pub mod rewrites;

// Re-export key functions
pub use categories::generate_category_rules;
pub use equations::generate_equation_rules;
pub use relations::generate_relations;

// Re-export congruence types and functions used by lib.rs
pub use congruence::{extract_collection_congruence_info, generate_congruence_projections};

pub use rewrites::{generate_freshness_functions, generate_rewrite_clauses};

/// Main entry point: Generate complete Ascent source for a theory
pub fn generate_ascent_source(theory: &TheoryDef) -> TokenStream {
    let theory_name = theory.name.to_string().to_lowercase();
    let source_name = format_ident!("{}_source", theory_name);

    let relations = generate_relations(theory);
    let category_rules = generate_category_rules(theory);
    let equation_rules = generate_equation_rules(theory);
    let rewrite_rules = generate_rewrite_rules(theory);

    let result = quote! {
        ::ascent::ascent_source! {
            #source_name:

            #relations

            #category_rules

            #equation_rules

            #rewrite_rules
        }
    };

    // Format and write the generated Ascent source to file
    let formatted_source = format_ascent_source(
        &theory_name,
        &source_name,
        &relations,
        &category_rules,
        &equation_rules,
        &rewrite_rules,
    );

    // Write to file for inspection
    if let Err(e) = writer::write_ascent_file(&theory.name.to_string(), &formatted_source) {
        eprintln!("Warning: Failed to write Ascent Datalog file: {}", e);
    }

    result
}

/// Format Ascent source for display and file output
fn format_ascent_source(
    theory_name: &str,
    source_name: &Ident,
    relations: &TokenStream,
    category_rules: &TokenStream,
    equation_rules: &TokenStream,
    rewrite_rules: &TokenStream,
) -> String {
    let mut output = String::new();

    output.push_str(&format!("// Generated Ascent Datalog for {} theory\n", theory_name));
    output.push_str("// This file is generated by the theory! macro and is for inspection only.\n");
    output.push_str("// Do not edit manually - changes will be overwritten.\n\n");

    output.push_str("ascent_source! {\n");
    output.push_str(&format!("    {}:\n\n", source_name));

    output.push_str("    // Relations\n");
    for line in relations.to_string().split(';') {
        output.push_str(&print_rule(line));
    }

    output.push_str("\n    // Category rules\n");
    for line in category_rules.to_string().split(';') {
        output.push_str(&print_rule(line));
    }

    output.push_str("\n    // Equation rules\n");
    for line in equation_rules.to_string().split(';') {
        output.push_str(&print_rule(line));
    }

    output.push_str("\n    // Rewrite rules\n");
    for line in rewrite_rules.to_string().split(';') {
        output.push_str(&print_rule(line));
    }

    output.push_str("}\n");

    output
}

/// Format a single Datalog rule for display
#[allow(dead_code)]
fn format_rule(line: &str) -> String {
    let trimmed = line.trim();
    if trimmed.is_empty() {
        return String::new();
    }

    // Use the existing print_rule logic but return string instead of printing
    if trimmed.contains("<--") {
        // It's a rule with body
        format!("{};", trimmed)
    } else if trimmed.starts_with("relation") || trimmed.starts_with("#[") {
        // It's a relation declaration or attribute
        format!("{};", trimmed)
    } else {
        // Other content
        trimmed.to_string()
    }
}

/// Generate rewrite rules: base rewrites + congruence rules
///
/// - **Base rewrites**: Rules without premises (S => T)
/// - **Collection congruences**: If S => T, then {S, ...} => {T, ...}
/// - **Regular congruences**: If S => T, then Constructor(S) => Constructor(T)
/// - **Binding congruences**: If S => T, then (new x.S) => (new x.T)
/// - **Auto variable retrieval**: if env_var(x, v) then (VarRef x) => v (for all categories)
pub fn generate_rewrite_rules(theory: &TheoryDef) -> TokenStream {
    let mut rules = Vec::new();

    // Generate base rewrite clauses (no premise)
    let base_rewrite_clauses = generate_rewrite_clauses(theory);
    rules.extend(base_rewrite_clauses);

    // Generate semantic evaluation rules (for operators with semantics)
    let semantic_rules = generate_semantic_rules(theory);
    rules.extend(semantic_rules);

    // Generate congruence rules (with premise: if S => T then ...)
    // For each collection congruence, generate projections and clauses
    for (cong_idx, rewrite) in theory.rewrites.iter().enumerate() {
        if let Some((source_var, target_var)) = &rewrite.premise {
            // Check if this is a collection congruence
            if let Some(cong_info) =
                extract_collection_congruence_info(&rewrite.left, source_var, target_var, theory)
            {
                // Generate all projections for this congruence
                let (projections, base_patterns) =
                    generate_congruence_projections(cong_idx, &cong_info, theory);
                rules.extend(projections);

                // Generate congruence clauses using those projections
                let congruence_clauses = congruence::generate_new_collection_congruence_clauses(
                    cong_idx,
                    &cong_info,
                    &base_patterns,
                    theory,
                );
                rules.extend(congruence_clauses);
            } else {
                // Regular (non-collection) congruence - dispatch to appropriate handler
                if let Some(rule) =
                    congruence::generate_congruence_rewrite(cong_idx, rewrite, theory)
                {
                    rules.push(rule);
                }
            }
        }
    }

    // Generate automatic variable retrieval rewrite rules for all categories
    let auto_var_rules = generate_automatic_var_retrieval_rules(theory);
    rules.extend(auto_var_rules);

    // Generate automatic Assign congruence rules
    let auto_assign_cong_rules = generate_automatic_assign_congruence_rules(theory);
    rules.extend(auto_assign_cong_rules);

    quote! {
        #(#rules)*
    }
}

/// Generate semantic evaluation rules for constructors with semantics
/// For example: Add (NumLit a) (NumLit b) => NumLit(a + b)
fn generate_semantic_rules(theory: &TheoryDef) -> Vec<TokenStream> {
    use crate::ast::SemanticOperation;

    let mut rules = Vec::new();

    for semantic in &theory.semantics {
        let constructor_name = &semantic.constructor;

        // Extract the operator
        let op_token = match &semantic.operation {
            SemanticOperation::Builtin(builtin_op) => {
                use crate::ast::BuiltinOp;
                match builtin_op {
                    BuiltinOp::Add => quote! { + },
                    BuiltinOp::Sub => quote! { - },
                    BuiltinOp::Mul => quote! { * },
                    BuiltinOp::Div => quote! { / },
                    BuiltinOp::Rem => quote! { % },
                    _ => continue, // Skip other operators
                }
            },
        };

        // Find the rule with this constructor
        if let Some(rule) = theory.terms.iter().find(|r| r.label == *constructor_name) {
            // Check if this is a binary operator (should have exactly 2 non-terminal fields)
            let non_terminals: Vec<_> = rule
                .items
                .iter()
                .filter_map(|item| {
                    if let crate::ast::GrammarItem::NonTerminal(nt) = item {
                        Some(nt)
                    } else {
                        None
                    }
                })
                .collect();

            if non_terminals.len() == 2 {
                let category = &rule.category;
                let label = &rule.label;

                // Generate rule with proper variable extraction in the head
                let rw_rel = format_ident!("rw_{}", category.to_string().to_lowercase());
                let cat_rel = format_ident!("{}", category.to_string().to_lowercase());
                let num_lit = format_ident!("NumLit");

                // Pattern: rw_cat(s, t) with body that matches and extracts a, b
                rules.push(quote! {
                    #rw_rel(s, t) <--
                        #cat_rel(s),
                        if let #category::#label(left, right) = s,
                        if let #category::#num_lit(a) = left.as_ref(),
                        if let #category::#num_lit(b) = right.as_ref(),
                        let t = #category::#num_lit(a #op_token b);
                });
            }
        }
    }

    rules
}

/// Generate automatic variable retrieval rewrite rules for all categories
/// For native types: if env_var(x, v) then (VarRef x) => (NumLit v)
/// For custom types: if env_var(x, v) then (PVar x) => v
fn generate_automatic_var_retrieval_rules(theory: &TheoryDef) -> Vec<TokenStream> {
    use crate::codegen::is_integer_rule;
    
    let mut rules = Vec::new();

    for export in &theory.exports {
        let category = &export.name;
        let cat_str = category.to_string();
        let cat_lower = format_ident!("{}", cat_str.to_lowercase());
        let rw_rel = format_ident!("rw_{}", cat_str.to_lowercase());
        let env_rel_name = format_ident!("env_var_{}", cat_str.to_lowercase());

        // Check if there's a Var rule (VarRef is auto-generated or explicit)
        let has_var_rule = theory.terms.iter().any(|rule| {
            rule.category == *category && is_var_rule(rule)
        });

        // Skip if no Var rule exists (VarRef is needed for variable retrieval)
        // Note: VarRef is auto-generated for non-native types, so this should usually be true
        if !has_var_rule && export.native_type.is_none() {
            continue;
        }

        // Use the explicit Var rule label if it exists, otherwise use auto-generated label
        let var_label = theory.terms.iter()
            .find(|rule| rule.category == *category && is_var_rule(rule))
            .map(|rule| rule.label.clone())
            .unwrap_or_else(|| generate_var_label(category));

        if let Some(_native_type) = &export.native_type {
            // Native type: if env_var(x, v) then (VarRef x) => (NumLit v)
            // Find the NumLit/Integer rule
            let integer_rule = theory.terms.iter().find(|rule| {
                rule.category == *category && is_integer_rule(rule)
            });
            
            if let Some(integer_rule) = integer_rule {
                let num_lit_label = &integer_rule.label;
                
                // Generate: if env_var(x, v) then (VarRef x) => (NumLit v)
                // v is the native type (e.g., i32) from env_var relation (bound as reference in Ascent)
                rules.push(quote! {
                    #rw_rel(s, t) <--
                        #cat_lower(s),
                        if let #category::#var_label(ord_var) = s,
                        if let Some(var_name) = match ord_var {
                            mettail_runtime::OrdVar(mettail_runtime::Var::Free(ref fv)) => {
                                fv.pretty_name.clone()
                            }
                            _ => None
                        },
                        #env_rel_name(var_name, v),
                        let t = #category::#num_lit_label(*v);
                });
            }
        } else {
            // Custom type: if env_var(x, v) then (PVar x) => v
            // v is the category type (e.g., Proc) from env_var relation
            rules.push(quote! {
                #rw_rel(s, t) <--
                    #cat_lower(s),
                    if let #category::#var_label(ord_var) = s,
                    if let Some(var_name) = match ord_var {
                        mettail_runtime::OrdVar(mettail_runtime::Var::Free(ref fv)) => {
                            fv.pretty_name.clone()
                        }
                        _ => None
                    },
                    #env_rel_name(var_name, v),
                    let t = v.clone();
            });
        }
    }

    rules
}

/// Generate automatic congruence rules for Assign constructors
/// if S => T then (Assign x S) => (Assign x T)
fn generate_automatic_assign_congruence_rules(theory: &TheoryDef) -> Vec<TokenStream> {
    let mut rules = Vec::new();

    for export in &theory.exports {
        let category = &export.name;
        let cat_str = category.to_string();

        // Assign is now always auto-generated for all categories (except those referenced by others)
        // So we always generate congruence rules for it
        // (No need to check has_assign_rule since we auto-generate it)

        let cat_lower = format_ident!("{}", cat_str.to_lowercase());
        let rw_rel = format_ident!("rw_{}", cat_str.to_lowercase());

        // Generate congruence rule: if S => T then (Assign x S) => (Assign x T)
        rules.push(quote! {
            #rw_rel(assign_s, assign_t) <--
                #cat_lower(assign_s),
                if let #category::Assign(x, s) = assign_s,
                #rw_rel((**s).clone(), t),
                let assign_t = #category::Assign(x.clone(), Box::new(t.clone()));
        });
    }

    rules
}
