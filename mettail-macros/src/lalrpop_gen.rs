// LALRPOP grammar generation for MeTTaIL theories
//
// This module generates `.lalrpop` grammar files from theory definitions.
// The generated grammars parse text into the AST types generated by codegen.rs

use crate::ast::{TheoryDef, GrammarRule, GrammarItem};

/// Generate a LALRPOP grammar file content for a theory
/// 
/// This produces the text content of a `.lalrpop` file that can parse
/// the theory's syntax into its AST types.
pub fn generate_lalrpop_grammar(theory: &TheoryDef) -> String {
    let theory_name = &theory.name;
    
    let mut grammar = String::new();
    
    // Add header
    grammar.push_str(&format!("// Generated LALRPOP grammar for theory: {}\n", theory_name));
    grammar.push_str("// This file is auto-generated - do not edit manually\n\n");
    
    // Add use statements for AST types
    grammar.push_str("use mettail_runtime::{Var, FreeVar, Binder, Scope};\n");
    
    // Import the AST types from the crate where the theory is defined
    // When used in test modules, this will be super::{...}
    // When used in library modules, LALRPOP will handle the paths correctly
    let type_names: Vec<String> = theory.exports.iter()
        .map(|e| e.name.to_string())
        .collect();
    
    if !type_names.is_empty() {
        grammar.push_str(&format!("use super::{{{}}};\n", type_names.join(", ")));
    }
    
    grammar.push_str("\n");
    
    // Add grammar directive
    grammar.push_str("grammar;\n\n");
    
    // Add identifier token definition (needed for binders and variables)
    grammar.push_str("Ident: String = {\n");
    grammar.push_str("    r\"[a-zA-Z_][a-zA-Z0-9_]*\" => <>.to_string(),\n");
    grammar.push_str("};\n\n");
    
    // Generate productions for each exported category
    for export in &theory.exports {
        let cat_name = &export.name;
        
        // Find all rules for this category
        let rules: Vec<&GrammarRule> = theory.terms
            .iter()
            .filter(|r| r.category == *cat_name)
            .collect();
        
        if !rules.is_empty() {
            grammar.push_str(&generate_category_production(cat_name, &rules));
            grammar.push_str("\n");
        }
    }
    
    grammar
}

/// Generate a LALRPOP production for a category
/// 
/// This handles precedence by creating tiered rules for infix operators
fn generate_category_production(category: &syn::Ident, rules: &[&GrammarRule]) -> String {
    let cat_str = category.to_string();
    
    // Classify rules by type
    let (infix_rules, other_rules): (Vec<&GrammarRule>, Vec<&GrammarRule>) = 
        rules.iter().map(|r| *r).partition(|r| is_infix_rule(r));
    
    // If we have infix operators, generate tiered rules for precedence
    if !infix_rules.is_empty() {
        generate_tiered_production(category, &infix_rules, &other_rules)
    } else {
        // No infix operators - generate simple production
        generate_simple_production(category, &other_rules)
    }
}

/// Check if a rule is an infix operator (e.g., Proc ::= Proc "|" Proc)
fn is_infix_rule(rule: &GrammarRule) -> bool {
    // An infix rule has the pattern: NonTerm (Terminal | NonTerm)+ NonTerm
    // where the first and last non-terminals are the same as the rule's category
    if rule.items.len() < 3 {
        return false;
    }
    
    // Check if first item is the same category
    let first_match = matches!(&rule.items[0], 
        GrammarItem::NonTerminal(nt) if nt == &rule.category);
    
    // Check if last item is the same category
    let last_match = matches!(rule.items.last(), 
        Some(GrammarItem::NonTerminal(nt)) if nt == &rule.category);
    
    // Check if there's a terminal in the middle (the operator)
    let has_terminal = rule.items[1..rule.items.len()-1].iter()
        .any(|item| matches!(item, GrammarItem::Terminal(_)));
    
    first_match && last_match && has_terminal
}

/// Generate tiered production for handling precedence
fn generate_tiered_production(
    category: &syn::Ident,
    infix_rules: &[&GrammarRule],
    other_rules: &[&GrammarRule]
) -> String {
    let cat_str = category.to_string();
    let mut production = String::new();
    
    // Top-level rule just delegates to the infix tier
    production.push_str(&format!("pub {}: {} = {{\n", cat_str, cat_str));
    production.push_str(&format!("    <{}Infix>\n", cat_str));
    production.push_str("};\n\n");
    
    // Infix tier - handles left-associative operators
    production.push_str(&format!("{}Infix: {} = {{\n", cat_str, cat_str));
    
    // Generate left-recursive rules for infix operators
    for (i, rule) in infix_rules.iter().enumerate() {
        production.push_str("    ");
        production.push_str(&generate_infix_alternative(rule, &cat_str));
        production.push_str(",\n");
    }
    
    // Base case - delegate to atom tier
    production.push_str(&format!("    <{}Atom>\n", cat_str));
    production.push_str("};\n\n");
    
    // Atom tier - handles non-infix constructs and parentheses
    production.push_str(&format!("{}Atom: {} = {{\n", cat_str, cat_str));
    
    // Add parenthesized expressions - reference the top-level rule
    production.push_str(&format!("    \"(\" <{}> \")\",\n", cat_str));
    
    // Add non-infix rules
    for (i, rule) in other_rules.iter().enumerate() {
        production.push_str("    ");
        production.push_str(&generate_rule_alternative(rule));
        
        if i < other_rules.len() - 1 {
            production.push_str(",\n");
        } else {
            production.push_str("\n");
        }
    }
    
    production.push_str("};\n");
    production
}

/// Generate alternative for infix operator (left-associative)
fn generate_infix_alternative(rule: &GrammarRule, cat_str: &str) -> String {
    let label = &rule.label;
    let category = &rule.category;
    
    // Pattern: <left:Cat> "op" <right:CatAtom>
    // This ensures left-associativity
    let mut pattern = format!("<left:{}Infix>", cat_str);
    let mut right_var = String::new();
    
    // Process items to find operator and right operand
    for (i, item) in rule.items.iter().enumerate() {
        if i == 0 {
            continue; // Skip first (it's the left operand)
        }
        
        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            }
            GrammarItem::NonTerminal(nt) if nt == category && i == rule.items.len() - 1 => {
                // Last item - use Atom tier to avoid ambiguity
                right_var = "right".to_string();
                pattern.push_str(&format!(" <{}:{}Atom>", right_var, cat_str));
            }
            GrammarItem::NonTerminal(nt) if nt == category => {
                // Middle recursive reference - shouldn't happen in binary infix
                pattern.push_str(&format!(" <mid{}>", i));
            }
            GrammarItem::NonTerminal(nt) => {
                pattern.push_str(&format!(" <f{}>", i));
            }
            GrammarItem::Binder { .. } => {
                // Binders in infix operators - unusual but handle it
                pattern.push_str(&format!(" <x_{}>", i));
            }
        }
    }
    
    // Generate action
    let action = format!(" => {}::{}(Box::new(left), Box::new(right))", category, label);
    
    format!("{}{}", pattern, action)
}

/// Generate simple production (no infix operators)
fn generate_simple_production(category: &syn::Ident, rules: &[&GrammarRule]) -> String {
    let mut production = String::new();
    
    // Production header: pub CategoryName: CategoryName = {
    production.push_str(&format!("pub {}: {} = {{\n", category, category));
    
    // Generate alternative for each rule
    for (i, rule) in rules.iter().enumerate() {
        production.push_str("    ");
        production.push_str(&generate_rule_alternative(rule));
        
        // Add comma unless it's the last rule
        if i < rules.len() - 1 {
            production.push_str(",\n");
        } else {
            production.push_str("\n");
        }
    }
    
    production.push_str("};\n");
    production
}

/// Generate a LALRPOP alternative for a single grammar rule
fn generate_rule_alternative(rule: &GrammarRule) -> String {
    let label = &rule.label;
    let mut alt = String::new();
    
    // Generate pattern for matching the syntax
    // Example: PZero . Proc ::= "0" ;
    //   becomes: "0" => Proc::PZero
    
    // Handle different cases based on rule structure
    if rule.items.len() == 1 {
        // Single item (terminal or non-terminal)
        match &rule.items[0] {
            GrammarItem::Terminal(term) => {
                // Terminal: just match the literal
                alt.push_str(&format!("\"{}\" => {}::{}", term, rule.category, label));
            }
            GrammarItem::NonTerminal(nt) if nt == "Var" => {
                // Variable: need to parse identifier
                alt.push_str(&format!("<v:Ident> => {}::{}(Var::Free(FreeVar::fresh_named(v)))", 
                    rule.category, label));
            }
            GrammarItem::NonTerminal(nt) => {
                // Non-terminal: recursively parse
                alt.push_str(&format!("<val:{}> => {}::{}(Box::new(val))", 
                    nt, rule.category, label));
            }
            GrammarItem::Binder { .. } => {
                // Binder alone shouldn't happen
                alt.push_str(&format!("// TODO: handle binder => {}::{}", rule.category, label));
            }
        }
    } else {
        // Multiple items: need to handle sequence
        alt.push_str(&generate_sequence_alternative(rule));
    }
    
    alt
}

/// Generate alternative for a rule with multiple items
fn generate_sequence_alternative(rule: &GrammarRule) -> String {
    let label = &rule.label;
    let category = &rule.category;
    
    // Check if this rule has binders
    if !rule.bindings.is_empty() {
        return generate_binder_alternative(rule);
    }
    
    let mut pattern = String::new();
    let mut args = Vec::new();
    let mut field_idx = 0;
    
    for item in &rule.items {
        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            }
            GrammarItem::NonTerminal(nt) => {
                let var_name = format!("f{}", field_idx);
                pattern.push_str(&format!(" <{}:{}>", var_name, nt));
                
                if nt.to_string() == "Var" {
                    args.push(var_name);
                } else {
                    args.push(format!("Box::new({})", var_name));
                }
                field_idx += 1;
            }
            GrammarItem::Binder { category: _binder_cat } => {
                // Binder: parse as identifier
                let var_name = format!("b{}", field_idx);
                pattern.push_str(&format!(" <{}:Ident>", var_name));
                // Binders are captured in Scope, handled separately
                field_idx += 1;
            }
        }
    }
    
    // Construct the AST node
    let args_str = args.join(", ");
    format!("{} => {}::{}({})", pattern.trim(), category, label, args_str)
}

/// Generate alternative for a rule with binders (creates Scope)
fn generate_binder_alternative(rule: &GrammarRule) -> String {
    let label = &rule.label;
    let category = &rule.category;
    
    let (binder_idx, body_indices) = &rule.bindings[0];
    let body_idx = body_indices[0];
    
    // Generate pattern and track which items go where
    let mut pattern = String::new();
    let mut regular_fields = Vec::new();
    let mut binder_var = String::new();
    let mut body_var = String::new();
    let mut field_idx = 0;
    
    for (i, item) in rule.items.iter().enumerate() {
        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            }
            GrammarItem::NonTerminal(nt) => {
                if i == body_idx {
                    // This is the body
                    body_var = format!("body_{}", field_idx);
                    pattern.push_str(&format!(" <{}:{}>", body_var, nt));
                } else {
                    // Regular field (not binder, not body)
                    let var_name = format!("f{}", field_idx);
                    pattern.push_str(&format!(" <{}:{}>", var_name, nt));
                    
                    if nt.to_string() == "Var" {
                        regular_fields.push(var_name);
                    } else {
                        regular_fields.push(format!("Box::new({})", var_name));
                    }
                }
                field_idx += 1;
            }
            GrammarItem::Binder { .. } => {
                if i == *binder_idx {
                    // This is the binder - parse as identifier
                    binder_var = format!("x_{}", field_idx);
                    pattern.push_str(&format!(" <{}:Ident>", binder_var));
                }
                field_idx += 1;
            }
        }
    }
    
    // Generate the action code that creates Scope
    // We need to extract the free variable from the body that matches the binder name
    // and use it as the binder, so moniker can properly bind it
    let mut action = format!(" => {{\n");
    action.push_str("        use mettail_runtime::BoundTerm;\n");
    action.push_str(&format!("        let free_vars = {}.free_vars();\n", body_var));
    action.push_str(&format!("        let binder = if let Some(fv) = free_vars.iter().find(|fv| fv.pretty_name.as_deref() == Some(&{})) {{\n", binder_var));
    action.push_str("            Binder((*fv).clone())\n");
    action.push_str("        } else {\n");
    action.push_str(&format!("            Binder(FreeVar::fresh_named({}))\n", binder_var));
    action.push_str("        };\n");
    action.push_str(&format!("        let scope = Scope::new(binder, Box::new({}));\n", body_var));
    
    // Build constructor call
    let mut all_args = regular_fields;
    all_args.push("scope".to_string());
    
    action.push_str(&format!("        {}::{}({})\n", category, label, all_args.join(", ")));
    action.push_str("    }");
    
    format!("{}{}", pattern.trim(), action)
}

/// Generate a token definition for identifiers
pub fn generate_ident_token() -> String {
    r#"Ident: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
};
"#.to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::*;
    use syn::parse_quote;
    
    #[test]
    fn test_rhocalc_grammar() {
        use std::fs;
        
        // Full Rho Calculus theory
        let theory = TheoryDef {
            name: parse_quote!(RhoCalc),
            params: vec![],
            exports: vec![
                Export { name: parse_quote!(Proc) },
                Export { name: parse_quote!(Name) },
            ],
            terms: vec![
                // Proc constructors
                GrammarRule {
                    label: parse_quote!(PZero),
                    category: parse_quote!(Proc),
                    items: vec![GrammarItem::Terminal("0".to_string())],
                    bindings: vec![],
                },
                GrammarRule {
                    label: parse_quote!(PInput),
                    category: parse_quote!(Proc),
                    items: vec![
                        GrammarItem::Terminal("for".to_string()),
                        GrammarItem::Terminal("(".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Name)),
                        GrammarItem::Binder { category: parse_quote!(Name) },
                        GrammarItem::Terminal(")".to_string()),
                        GrammarItem::Terminal("{".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Proc)),
                        GrammarItem::Terminal("}".to_string()),
                    ],
                    bindings: vec![(3, vec![6])], // Item 3 (binder) binds in item 6 (body)
                },
                GrammarRule {
                    label: parse_quote!(POutput),
                    category: parse_quote!(Proc),
                    items: vec![
                        GrammarItem::NonTerminal(parse_quote!(Name)),
                        GrammarItem::Terminal("!".to_string()),
                        GrammarItem::Terminal("(".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Proc)),
                        GrammarItem::Terminal(")".to_string()),
                    ],
                    bindings: vec![],
                },
                GrammarRule {
                    label: parse_quote!(PPar),
                    category: parse_quote!(Proc),
                    items: vec![
                        GrammarItem::NonTerminal(parse_quote!(Proc)),
                        GrammarItem::Terminal("|".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Proc)),
                    ],
                    bindings: vec![],
                },
                GrammarRule {
                    label: parse_quote!(PDrop),
                    category: parse_quote!(Proc),
                    items: vec![
                        GrammarItem::Terminal("*".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Name)),
                    ],
                    bindings: vec![],
                },
                // Name constructors
                GrammarRule {
                    label: parse_quote!(NQuote),
                    category: parse_quote!(Name),
                    items: vec![
                        GrammarItem::Terminal("@".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Proc)),
                    ],
                    bindings: vec![],
                },
                GrammarRule {
                    label: parse_quote!(NVar),
                    category: parse_quote!(Name),
                    items: vec![GrammarItem::NonTerminal(parse_quote!(Var))],
                    bindings: vec![],
                },
            ],
            equations: vec![],
            rewrites: vec![],
        };
        
        let grammar = generate_lalrpop_grammar(&theory);
        
        println!("\n=== Generated Rho Calculus Grammar ===\n{}", grammar);
        
        // Write to file
        let target_dir = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("target")
            .join("test_grammars");
        
        fs::create_dir_all(&target_dir).unwrap();
        fs::write(target_dir.join("rhocalc.lalrpop"), &grammar).unwrap();
        
        println!("âœ“ Wrote grammar to: {}", target_dir.join("rhocalc.lalrpop").display());
        
        // Verify Rho-specific constructs
        assert!(grammar.contains("pub Proc: Proc"));
        assert!(grammar.contains("pub Name: Name"));
        assert!(grammar.contains("PZero"));
        assert!(grammar.contains("PInput"));
        assert!(grammar.contains("Binder(FreeVar::fresh_named"));
        assert!(grammar.contains("Scope::new"));
        assert!(grammar.contains("\"for\""));
        assert!(grammar.contains("\"@\""));
        assert!(grammar.contains("\"|\""));
    }
}

