# Performance Analysis: Ascent-Generated Code

## Problem Summary

The `rhocalc.rs` example is experiencing severe performance issues:
- Simple redex takes ~15 seconds to find 180 paths
- Slightly more complex redex takes "way too long" (likely minutes or hours)
- Ascent is a high-performance Datalog engine capable of handling millions of facts efficiently
- Current implementation is not leveraging Ascent's capabilities effectively

## Root Causes Identified

### 1. **CRITICAL: Unbounded Term Explosion via Equality Relations**

The generated Ascent code creates an explosive feedback loop:

```datalog
// Category exploration
proc(c1) <-- proc(c0), eq_proc(c0, c1);

// Reflexivity (GENERATES ALL TERMS AS EQUAL TO THEMSELVES)
eq_proc(t, t) <-- proc(t);

// Symmetry (DOUBLES THE RELATION)
eq_proc(b, a) <-- eq_proc(a, b);

// Transitivity (EXPONENTIAL BLOWUP)
eq_proc(a, c) <-- eq_proc(a, b), eq_proc(b, c);
```

**Problem**: For every term discovered in `proc(...)`, we add it to `eq_proc` via reflexivity. Then transitivity creates O(n²) or O(n³) equality facts. Then category exploration uses these equalities to generate even MORE terms, creating an exponential feedback loop.

**Impact**: With 180 final paths, the intermediate `eq_proc` relation likely contains tens of thousands or millions of entries.

### 2. **Inefficient Transitive Closure Pattern**

The user's code in `rhocalc.rs`:

```rust
path(p.clone(),q.clone()) <-- rw_proc(p,q);
path(p.clone(),r.clone()) <-- rw_proc(p,q),path(q.clone(),r);
```

**Issues**:
- Using **non-linear** transitive closure pattern (less efficient than linear)
- Manual transitive closure instead of using `trrel` data structure
- From the Ascent `transitive_graph_closure.rs` example:
  ```rust
  // Linear rule (BETTER - what we should use):
  reachable(x, z) <-- reachable(x, y), edge(y, z);

  // Non-linear rule (WORSE - what we're currently using):
  reachable(x, z) <-- reachable(x, y), reachable(y, z);
  ```

**Impact**: The non-linear pattern redundantly discovers intermediate facts, causing n-1 redundant iterations.

### 3. **Mixing Equality and Rewriting in Category Exploration**

Currently generated:

```datalog
proc(c1) <-- proc(c0), rw_proc(c0, c1);
proc(c1) <-- proc(c0), eq_proc(c0, c1);
```

**Problem**: This means:
1. Every rewrite generates a new term
2. That term is added to `eq_proc` reflexively
3. Equations generate more equal terms
4. All those equal terms are fed back into category exploration
5. Category exploration deconstructs them, discovering their subterms
6. Those subterms are added to `eq_proc` reflexively
7. GOTO 1

This is an **exponential term explosion**.

### 4. **Excessive Cloning**

Every rule has `.clone()` calls:

```datalog
path(p.clone(),q.clone()) <-- rw_proc(p,q);
path(p.clone(),r.clone()) <-- rw_proc(p,q),path(q.clone(),r);
```

With complex term structures (Rho calculus processes with binders), cloning is expensive.

### 5. **Deconstruction Rules Run on ALL Generated Terms**

```datalog
name(*field_0.clone()), proc(*field_1.clone()) <--
    proc(t), if let Proc::POutput(field_0, field_1) = t;
```

Every term generated by equations or rewrites gets deconstructed, adding its subterms to exploration, which get their own equality relations, which generate more terms...

### 6. **Negation in Critical Path**

```rust
path_full(p.clone(),z.clone()) <--
    eq_proc(p,redex.clone()), path(p.clone(),z), !rw_proc(z.clone(),_);
```

The negation `!rw_proc(z.clone(),_)` requires checking the absence of a rewrite for every path endpoint. This is expensive when `rw_proc` is large.

## Recommended Solutions

### Solution 1: Limit Equality Propagation (CRITICAL)

**Option A**: Remove reflexivity/symmetry/transitivity from automatically populating exploration

**Option B**: Only compute equality *on demand* for specific queries, not eagerly

**Option C**: Use a union-find/eqrel data structure properly to avoid explicit transitivity

**Recommendation**: Separate "exploration" from "equality checking". Don't feed equality back into exploration automatically.

```datalog
// Exploration: Only follow direct rewrites
proc(c1) <-- proc(c0), rw_proc(c0, c1);

// Equality: Compute separately, use eqrel data structure
#[ds(crate::eqrel)]
relation eq_proc(Proc, Proc);
eq_proc(a, b) <-- proc(a), proc(b), /* explicit equation rules only */
```

### Solution 2: Use Linear Transitive Closure

Change from:
```datalog
path(p,q) <-- rw_proc(p,q);
path(p,r) <-- rw_proc(p,q), path(q,r);  // NON-LINEAR
```

To:
```datalog
path(p,q) <-- rw_proc(p,q);
path(p,r) <-- path(p,q), rw_proc(q,r);  // LINEAR
```

### Solution 3: Lazy Deconstruction

Only deconstruct terms when needed for rewrites, not eagerly for all terms.

### Solution 4: Separate Rewrite Graph from Equality Graph

```datalog
// Rewrite graph: Only direct rewrites
relation rw_proc(Proc, Proc);

// Reachability: Transitive closure of rewrites
relation path(Proc, Proc);
path(p,q) <-- rw_proc(p,q);
path(p,r) <-- path(p,q), rw_proc(q,r);

// Equality: Computed separately
relation eq_proc(Proc, Proc);
// Only compute when explicitly needed
```

### Solution 5: Remove Cloning Where Possible

Ascent should be able to work with references in many cases. Need to review generated code to minimize cloning.

### Solution 6: Use `trrel` Data Structure Properly

The `path` relation should use `#[ds(crate::trrel)]` to get optimized transitive closure:

```rust
#[ds(crate::trrel)]
relation path(Proc, Proc);
path(p, q) <-- rw_proc(p, q);
// trrel will handle transitive closure efficiently
```

## Immediate Action Items

1. **Disable equality propagation in category exploration** (biggest impact)
2. **Switch to linear transitive closure pattern**
3. **Consider using `trrel` for the path relation**
4. **Profile to confirm the bottleneck** (measure size of `eq_proc`, `proc`, `rw_proc` relations)

## Performance Expectations

After fixes, for a moderately complex term rewriting system:
- Should handle 1000s of terms in < 1 second
- Should handle 10,000s of terms in < 10 seconds
- Current 180 paths should take < 100ms

## References

- Ascent `transitive_graph_closure.rs` example for efficient TC patterns
- Ascent `bench_trrel.rs` for specialized transitive relation data structures
- eqrel documentation for union-find-based equality relations

